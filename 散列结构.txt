高效的散列算法：
1.把键按照一定的规则塞到长度为M的数组中
2.使数尽量散列开来，均匀的分布到数组当中，避免数组一个位置里面太多的键
3.这种运算对于计算机来说，开销越小越好


经典散列方法：
1）除留余数法：只是解决了键塞到数组中，但是散列均匀情况未做考虑。如果待插入的数字都是M的整数倍，那么所有的元素都会被塞到数组的第一个位置arr[0]的位置
把键转换为数字，除以M（数组大小）求余数，就是所在数组中的下标位置了。
例如 数字101 在 数组长度为10中的，余数为1，所以就在arr[1]的位置了。
2）二进制 与运算


散列表的两种实现方式：拉链法和线性探测法，但是这两种方法的高效都依赖有一个 好的散列算法（足够散列、算法对计算机运算友好），同时也都要支持动态调整大小。
相对于树形结构，散列表不具有排序功能，但是查找的性能是在常数级别，而不是对数级别。插入性能的话，散列表的性能依赖于 N/M 因子的设置和散列算法，总体而言肯定是高于树形结构。
牺牲的是没有了顺序功能。

拉链法：hashmap的实现原理，一个小的数组 每个位置都是一个链表，通过散列求到对应的数组下标，看该位置是否有元素，有的话，遍历是否有同样的值后插进去。
线性探测法：要求一个相对较大的数组，一般 元素总数:数组长度 <1：2，通过散列算法求到对应的数组下标，如果该位置已经有元素，则继续往后，直到找到null位置插入。
线性探测法在删除元素的时候，需要把后续的簇元素全部重新插入，相对来说，拉链法更容易实现。但是如果连续的内存越多的话，线性探测法的簇很短的话，线性探测法更快。

java方面（TreeMap 红黑树、HashMap基于拉链法的散列结构）